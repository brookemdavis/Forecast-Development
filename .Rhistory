obj <- MakeADFun(data, param, DLL="Single_Stock_Larkin", silent=TRUE)
opt <- nlminb(obj$par, obj$fn, obj$gr, control = list(eval.max = 1e5, iter.max = 1e5))
# pull out estimates from ML fit
# Create Table of outputs
All_Ests <- data.frame(summary(sdreport(obj)))
All_Ests$Param <- row.names(All_Ests)
All_Ests
xx <- 4:50
length(xx)
xx <- 3:49
length(xx)
library(dplyr)
library(ggplot2)
library(TMB)
library(R2jags)
source("Code/Functions.R")
##==================================================================================
#Get TMB model ready
# only need to compile if changed model
dyn.unload(dynlib("Code/TMB/Single_Stock_Larkin"))
compile("Code/TMB/Single_Stock_Larkin.cpp") # can't seem to compile if have TMBstan loaded
dyn.load(dynlib("Code/TMB/Single_Stock_Larkin"))
SimData <- Sim_Larkin_SR_Data( leng=70, age=4, Sig_Larkin = 0.2, true_a = 4, true_b=c(1/10000, 0.00006, 0.00004, 0.00002),
hr_min = 0.2, hr_max = 0.8, lnorm_corr = F, autoCorr = F, rho=NA)
# get too perfect of cycles at beginning -- do "burn in" of 20 years -- do after get fits
SimDataDF <- data.frame(S = round(SimData$S), R = (SimData$R), Year = 1:(length(SimData$S)))
# Create DF to store true and fitted values
DataDF <- SimDataDF[, c("S", "R", "Year")]
DataDF$Fit <- NA
# How to do this for Larkin?
for(i in 20:70){
DataDF$Fit[i] <- SimData$true_a * DataDF$S[i] * exp(-SimData$true_b[1]*DataDF$S[i] -
SimData$true_b[2]*DataDF$S[i-1] -
SimData$true_b[3]*DataDF$S[i-2] -
SimData$true_b[4]*DataDF$S[i-3] )
}
DataDF$Mod <- "True"
DataDF$CI_low <- DataDF$CI_up  <-  DataDF$Pred <- DataDF$Pred_low <- DataDF$Pred_up <- DataDF$Fit
DataDF <- DataDF %>% filter(Year > 20)
ggplot(data = DataDF, aes(x=S, y=Fit)) +
geom_line(size = 1.5, col = "red") +
geom_point(aes(x=S, y=R), col = "black")
ggplot(data = DataDF, aes(x=Year, y=R)) +
geom_line(size = 1.5) +
geom_line(aes(x=Year, y=Fit), col = "red")
# run using TMB, without prior
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
# Now Fit TMB model
obj <- MakeADFun(data, param, DLL="Single_Stock_Larkin", silent=TRUE)
opt <- nlminb(obj$par, obj$fn, obj$gr, control = list(eval.max = 1e5, iter.max = 1e5))
# pull out estimates from ML fit
# Create Table of outputs
All_Ests <- data.frame(summary(sdreport(obj)))
All_Ests$Param <- row.names(All_Ests)
All_Ests
obj <- MakeADFun(data, param, DLL="Single_Stock_Larkin", silent=TRUE)
opt <- nlminb(obj$par, obj$fn, obj$gr, control = list(eval.max = 1e5, iter.max = 1e5))
# pull out estimates from ML fit
# Create Table of outputs
All_Ests <- data.frame(summary(sdreport(obj)))
All_Ests$Param <- row.names(All_Ests)
All_Ests
dyn.unload(dynlib("Code/TMB/Single_Stock_Larkin"))
compile("Code/TMB/Single_Stock_Larkin.cpp") # can't seem to compile if have TMBstan loaded
dyn.load(dynlib("Code/TMB/Single_Stock_Larkin"))
#Get TMB model ready
# only need to compile if changed model
dyn.unload(dynlib("Code/TMB/Single_Stock_Larkin"))
compile("Code/TMB/Single_Stock_Larkin.cpp") # can't seem to compile if have TMBstan loaded
dyn.load(dynlib("Code/TMB/Single_Stock_Larkin"))
SimData <- Sim_Larkin_SR_Data( leng=70, age=4, Sig_Larkin = 0.2, true_a = 4, true_b=c(1/10000, 0.00006, 0.00004, 0.00002),
hr_min = 0.2, hr_max = 0.8, lnorm_corr = F, autoCorr = F, rho=NA)
# get too perfect of cycles at beginning -- do "burn in" of 20 years -- do after get fits
SimDataDF <- data.frame(S = round(SimData$S), R = (SimData$R), Year = 1:(length(SimData$S)))
# Create DF to store true and fitted values
DataDF <- SimDataDF[, c("S", "R", "Year")]
DataDF$Fit <- NA
# How to do this for Larkin?
for(i in 20:70){
DataDF$Fit[i] <- SimData$true_a * DataDF$S[i] * exp(-SimData$true_b[1]*DataDF$S[i] -
SimData$true_b[2]*DataDF$S[i-1] -
SimData$true_b[3]*DataDF$S[i-2] -
SimData$true_b[4]*DataDF$S[i-3] )
}
DataDF$Mod <- "True"
DataDF$CI_low <- DataDF$CI_up  <-  DataDF$Pred <- DataDF$Pred_low <- DataDF$Pred_up <- DataDF$Fit
DataDF <- DataDF %>% filter(Year > 20)
ggplot(data = DataDF, aes(x=S, y=Fit)) +
geom_line(size = 1.5, col = "red") +
geom_point(aes(x=S, y=R), col = "black")
ggplot(data = DataDF, aes(x=Year, y=R)) +
geom_line(size = 1.5) +
geom_line(aes(x=Year, y=Fit), col = "red")
# run using TMB, without prior
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
source("Code/Functions.R")
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
source("Code/Functions.R")
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
# create new rows with fitted values
FitsDF <- data.frame(S = Data$S, R = NA, Fit = R_Ests$R_Fit, Year = 1:dim(R_Ests)[1],
Mod = Name)
R_Ests
length(R_Ests)
B_Means
B_means
# add 3 NAs to R_Ests at beginning so aligns with data
R_Ests <- c(rep(NA, (length(B_means)-1)), R_Ests)
R_Ests
# pull out fitted values
R_Ests <- All_Ests[grepl("R_Fit", All_Ests$Param),  ] [, -3 ]
names(R_Ests) <- c("R_Fit", "StdErr")
# add 3 NAs to R_Ests at beginning so aligns with data
R_Ests$R_Fit <- c(rep(NA, (length(B_means)-1)), R_Ests$R_Fit)
R_Ests$StdErr <- c(rep(NA, (length(B_means)-1)), R_Ests$StdErr)
# pull out fitted values
R_Ests <- All_Ests[grepl("R_Fit", All_Ests$Param),  ] [, -3 ]
R_Ests
# pull out fitted values
R_Ests_Raw <- All_Ests[grepl("R_Fit", All_Ests$Param),  ] [, -3 ]
# pull out fitted values
R_Ests_Raw <- All_Ests[grepl("R_Fit", All_Ests$Param),  ] [, -3 ]
# add 3 NAs to R_Ests at beginning so aligns with data
R_Ests <- data.frame(R_Fit = c(rep(NA, (length(B_means)-1)), R_Ests_Raw$Estimate),
StdErr = c(rep(NA, (length(B_means)-1)), R_Ests_Raw$Std..Error) )
R_Ests
# create new rows with fitted values
FitsDF <- data.frame(S = Data$S, R = NA, Fit = R_Ests$R_Fit, Year = 1:dim(R_Ests)[1],
Mod = Name)
FitsDF
FitsDF$CI_low <- R_Ests$R_Fit - 1.96*R_Ests$StdErr
FitsDF$CI_up <- R_Ests$R_Fit + 1.96*R_Ests$StdErr
FitsDF
R_Preds <- matrix(nrow = 1000, ncol = 50)
for(i in 1:1000){
R_Preds[i, ] <- obj$simulate()$R_Pred
}
R_Pred_Summ <- apply(R_Preds, 2, quantile, probs = c(0.025, 0.5, 0.975))
dim(Data)
# create prediction interval using simulate
R_Preds <- matrix(nrow = 1000, ncol = (dim(Data)[1]-length(B_means)+1) )
dim(R_Preds)
# create prediction interval using simulate
R_Preds <- matrix(nrow = 1000, ncol = (dim(Data)[1]-length(B_means)+1) )
for(i in 1:1000){
R_Preds[i, ] <- obj$simulate()$R_Pred
}
obj$simulate()$R_Pred
xx <- obj$simulate()$R_Pred
length(xx)
R_Preds <- matrix(nrow = 1000, ncol = (dim(Data)[1]-length(B_means)+1) )
for(i in 1:1000){
R_Preds[i, ] <- obj$simulate()$R_Pred
}
obj$simulate()$R_Pred
R_Pred_Summ <- apply(R_Preds, 2, quantile, probs = c(0.025, 0.5, 0.975))
R_Preds
i<-1
obj$simulate()$R_Pred
R_Preds[i, ] <- obj$simulate()$R_Pred
R_Preds
for(i in 1:1000){
R_Preds[i, ] <- obj$simulate()$R_Pred
}
source("Code/Functions.R")
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
R_Pred_Summ <- apply(R_Preds, 2, quantile, probs = c(0.025, 0.5, 0.975))
R_Pred_Summ
# also need to add NAs to beginning of these vectors
FitsDF$Pred <- c(rep(NA, (length(B_means)-1)), R_Pred_Summ[2,])
FitsDF$Pred_low <- c(rep(NA, (length(B_means)-1)),R_Pred_Summ[1,] )
FitsDF$Pred_up<- c(rep(NA, (length(B_means)-1)),R_Pred_Summ[3,])
FitsDF
source("Code/Functions.R")
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
TMB_No_Prior
# Run same model as mcmc using tmbstan
library(tmbstan)
tmbstan_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
A_mean = SimData$true_a,
A_sig =SimData$true_a/4,
B_mean = SimData$true_b,
B_sig = SimData$true_b/4)
source("Code/Functions.R")
tmbstan_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
A_mean = SimData$true_a,
A_sig =SimData$true_a/4,
B_mean = SimData$true_b,
B_sig = SimData$true_b/4)
source("Code/Functions.R")
tmbstan_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
A_mean = SimData$true_a,
A_sig =SimData$true_a/4,
B_mean = SimData$true_b,
B_sig = SimData$true_b/4)
library(dplyr)
library(ggplot2)
library(TMB)
library(R2jags)
source("Code/Functions.R")
##==================================================================================
#Get TMB model ready
# only need to compile if changed model
dyn.unload(dynlib("Code/TMB/Single_Stock_Larkin"))
compile("Code/TMB/Single_Stock_Larkin.cpp") # can't seem to compile if have TMBstan loaded
dyn.load(dynlib("Code/TMB/Single_Stock_Larkin"))
# simulate some Larkin model data
SimData <- Sim_Larkin_SR_Data( leng=70, age=4, Sig_Larkin = 0.2, true_a = 4, true_b=c(1/10000, 0.00006, 0.00004, 0.00002),
hr_min = 0.2, hr_max = 0.8, lnorm_corr = F, autoCorr = F, rho=NA)
# get too perfect of cycles at beginning -- do "burn in" of 20 years -- do after get fits
SimDataDF <- data.frame(S = round(SimData$S), R = (SimData$R), Year = 1:(length(SimData$S)))
# Create DF to store true and fitted values
DataDF <- SimDataDF[, c("S", "R", "Year")]
DataDF$Fit <- NA
# How to do this for Larkin?
for(i in 20:70){
DataDF$Fit[i] <- SimData$true_a * DataDF$S[i] * exp(-SimData$true_b[1]*DataDF$S[i] -
SimData$true_b[2]*DataDF$S[i-1] -
SimData$true_b[3]*DataDF$S[i-2] -
SimData$true_b[4]*DataDF$S[i-3] )
}
DataDF$Mod <- "True"
DataDF$CI_low <- DataDF$CI_up  <-  DataDF$Pred <- DataDF$Pred_low <- DataDF$Pred_up <- DataDF$Fit
DataDF <- DataDF %>% filter(Year > 20)
ggplot(data = DataDF, aes(x=S, y=Fit)) +
geom_line(size = 1.5, col = "red") +
geom_point(aes(x=S, y=R), col = "black")
ggplot(data = DataDF, aes(x=Year, y=R)) +
geom_line(size = 1.5) +
geom_line(aes(x=Year, y=Fit), col = "red")
# run using TMB, without prior
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
# Now run with priors same as "true" values
TMB_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "TMB",
Priors = T, Name = "TMB_True_Prior",
A_mean = SimData$true_a,
A_sig = SimData$true_a/4,
B_mean = SimData$true_b,
B_sig = SimData$true_b/4)
SimData$true_b
# Now run with priors same as "true" values
TMB_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "TMB",
Priors = T, Name = "TMB_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
TMB_True_Prior
tmbstan_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
# Run same model as mcmc using tmbstan
library(tmbstan)
tmbstan_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
# pull out R_Fit values
R_Fit_Med <- obj$report(All_Ests[1,-ncol(All_Ests)])$R_Fit
dim(R_Fit_Med)
R_Fit_Med
dim(R_Fit_Med)
length(R_Fit_Med)
R_Fit_Med <- obj$report(All_Ests[1,-ncol(All_Ests)])$R_Fit
R_Fit <- matrix(NA, nrow=nrow(All_Ests), ncol = length(R_Fit_Med))
for(i in 1:nrow(All_Ests)){
r <- obj$report(All_Ests[i,-ncol(All_Ests)])
R_Fit[i,] <- r$R_Fit
}
source("Code/Functions.r")
tmbstan_True_Prior <- RunLarkin(Data = SimDataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
R_Fit_Med
All_Ests
length(R_Fit_Med)
obj$report(All_Ests[1,-ncol(All_Ests)])
data
length(Data$S)
SimData <- Sim_Larkin_SR_Data( leng=70, age=4, Sig_Larkin = 0.2, true_a = 4, true_b=c(1/10000, 0.00006, 0.00004, 0.00002),
hr_min = 0.2, hr_max = 0.8, lnorm_corr = F, autoCorr = F, rho=NA)
# get too perfect of cycles at beginning -- do "burn in" of 20 years -- do after get fits
SimDataDF <- data.frame(S = round(SimData$S), R = (SimData$R), Year = 1:(length(SimData$S)))
# Create DF to store true and fitted values
DataDF <- SimDataDF[, c("S", "R", "Year")]
DataDF$Fit <- NA
# How to do this for Larkin?
for(i in 20:70){
DataDF$Fit[i] <- SimData$true_a * DataDF$S[i] * exp(-SimData$true_b[1]*DataDF$S[i] -
SimData$true_b[2]*DataDF$S[i-1] -
SimData$true_b[3]*DataDF$S[i-2] -
SimData$true_b[4]*DataDF$S[i-3] )
}
DataDF$Mod <- "True"
DataDF$CI_low <- DataDF$CI_up  <-  DataDF$Pred <- DataDF$Pred_low <- DataDF$Pred_up <- DataDF$Fit
DataDF <- DataDF %>% filter(Year > 20)
ggplot(data = DataDF, aes(x=S, y=Fit)) +
geom_line(size = 1.5, col = "red") +
geom_point(aes(x=S, y=R), col = "black")
ggplot(data = DataDF, aes(x=Year, y=R)) +
geom_line(size = 1.5) +
geom_line(aes(x=Year, y=Fit), col = "red")
SimData <- Sim_Larkin_SR_Data( leng=70, age=4, Sig_Larkin = 0.2, true_a = 4, true_b=c(1/10000, 0.00006, 0.00004, 0.00002),
hr_min = 0.2, hr_max = 0.8, lnorm_corr = F, autoCorr = F, rho=NA)
# get too perfect of cycles at beginning -- do "burn in" of 20 years -- do after get fits
SimDataDF <- data.frame(S = round(SimData$S), R = (SimData$R), Year = 1:(length(SimData$S)))
# Create DF to store true and fitted values
DataDF <- SimDataDF[, c("S", "R", "Year")]
DataDF$Fit <- NA
# How to do this for Larkin?
for(i in 20:70){
DataDF$Fit[i] <- SimData$true_a * DataDF$S[i] * exp(-SimData$true_b[1]*DataDF$S[i] -
SimData$true_b[2]*DataDF$S[i-1] -
SimData$true_b[3]*DataDF$S[i-2] -
SimData$true_b[4]*DataDF$S[i-3] )
}
DataDF$Mod <- "True"
DataDF$CI_low <- DataDF$CI_up  <-  DataDF$Pred <- DataDF$Pred_low <- DataDF$Pred_up <- DataDF$Fit
DataDF <- DataDF %>% filter(Year > 20)
ggplot(data = DataDF, aes(x=S, y=Fit)) +
geom_line(size = 1.5, col = "red") +
geom_point(aes(x=S, y=R), col = "black")
ggplot(data = DataDF, aes(x=Year, y=R)) +
geom_line(size = 1.5) +
geom_line(aes(x=Year, y=Fit), col = "red")
dim(SimDataDF)
tmbstan_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
R_Fit_Med
length(R_Fit_med)
length(R_Fit_Med)
dim(R_Fit)
# now for each column get median, quantiles and add to DF
R_Fit_Summ <- apply(R_Fit, 2, quantile, probs = c(0.025, 0.5, 0.975))
length(Data$S)
c(rep(NA, length(B_means)-1)), R_Fit_Summ[2,])
c(rep(NA, length(B_means)-1), R_Fit_Summ[2,])
FitsDF <- data.frame(S = Data$S, R = Data$R,
Fit = c(rep(NA, length(B_means)-1), R_Fit_Summ[2,]),
Year = 1:length(Data$S),   Mod = Name,
CI_up = c(rep(NA, length(B_means)-1), R_Fit_Summ[1,]),
CI_low = c(rep(NA, length(B_means)-1), R_Fit_Summ[3,]),
Pred = c(rep(NA, length(B_means)-1), R_Pred_Summ[2,]),
Pred_low = c(rep(NA, length(B_means)-1), R_Pred_Summ[1,]),
Pred_up = c(rep(NA, length(B_means)-1), R_Pred_Summ[3,]) )
R_Pred_Summ <- apply(R_Preds, 2, quantile, probs = c(0.025, 0.5, 0.975))
R_Preds <- matrix(nrow = 1000, ncol = (dim(Data)[1]-length(B_means)+1))
for(i in 1:1000){
R_Preds[i, ] <- obj$simulate()$R_Pred
}
tmbstan_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
source("Code/Functions.r")
tmbstan_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
tmbstan_True_Prior
source("Code/Functions.r")
tmbstan_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
FitsDF <- data.frame(S = Data$S, R = Data$R,
Fit = c(rep(NA, length(B_means)-1), R_Fit_Summ[2,]),
Year = 1:length(Data$S),   Mod = Name,
CI_up = c(rep(NA, length(B_means)-1), R_Fit_Summ[1,]),
CI_low = c(rep(NA, length(B_means)-1), R_Fit_Summ[3,]),
Pred = c(rep(NA, length(B_means)-1), R_Pred_Summ[2,]),
Pred_low = c(rep(NA, length(B_means)-1), R_Pred_Summ[1,]),
Pred_up = c(rep(NA, length(B_means)-1), R_Pred_Summ[3,]) )
FitsDF
# prepare posteriors for return
A_Post <- exp(All_Ests[, c("logA")])
Smax_Post <- exp(All_Ests[, c("logSmax")])*Scale
All_Ests
tmbstan_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
source("Code/Functions.R")
SimData <- Sim_Larkin_SR_Data( leng=70, age=4, Sig_Larkin = 0.2, true_a = 4, true_b=c(1/10000, 0.00006, 0.00004, 0.00002),
hr_min = 0.2, hr_max = 0.8, lnorm_corr = F, autoCorr = F, rho=NA)
# get too perfect of cycles at beginning -- do "burn in" of 20 years -- do after get fits
SimDataDF <- data.frame(S = round(SimData$S), R = (SimData$R), Year = 1:(length(SimData$S)))
# Create DF to store true and fitted values
DataDF <- SimDataDF[, c("S", "R", "Year")]
DataDF$Fit <- NA
# How to do this for Larkin?
for(i in 20:70){
DataDF$Fit[i] <- SimData$true_a * DataDF$S[i] * exp(-SimData$true_b[1]*DataDF$S[i] -
SimData$true_b[2]*DataDF$S[i-1] -
SimData$true_b[3]*DataDF$S[i-2] -
SimData$true_b[4]*DataDF$S[i-3] )
}
DataDF$Mod <- "True"
DataDF$CI_low <- DataDF$CI_up  <-  DataDF$Pred <- DataDF$Pred_low <- DataDF$Pred_up <- DataDF$Fit
DataDF <- DataDF %>% filter(Year > 20)
ggplot(data = DataDF, aes(x=S, y=Fit)) +
geom_line(size = 1.5, col = "red") +
geom_point(aes(x=S, y=R), col = "black")
ggplot(data = DataDF, aes(x=Year, y=R)) +
geom_line(size = 1.5) +
geom_line(aes(x=Year, y=Fit), col = "red")
# run using TMB, without prior
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
# In forecast version all priors for betas are 0, 0.001
# Now run with priors same as "true" values
TMB_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "TMB",
Priors = T, Name = "TMB_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
# Run same model as mcmc using tmbstan
library(tmbstan)
tmbstan_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
source("Code/Functions.R")
SimData <- Sim_Larkin_SR_Data( leng=70, age=4, Sig_Larkin = 0.2, true_a = 4,
true_b=c(1/10000, 0.00006, 0.00004, 0.00002),
hr_min = 0.2, hr_max = 0.8, lnorm_corr = F, autoCorr = F, rho=NA)
# get too perfect of cycles at beginning -- do "burn in" of 20 years -- do after get fits
SimDataDF <- data.frame(S = round(SimData$S), R = (SimData$R), Year = 1:(length(SimData$S)))
# Create DF to store true and fitted values
DataDF <- SimDataDF[, c("S", "R", "Year")]
DataDF$Fit <- NA
# How to do this for Larkin?
for(i in 20:70){
DataDF$Fit[i] <- SimData$true_a * DataDF$S[i] * exp(-SimData$true_b[1]*DataDF$S[i] -
SimData$true_b[2]*DataDF$S[i-1] -
SimData$true_b[3]*DataDF$S[i-2] -
SimData$true_b[4]*DataDF$S[i-3] )
}
DataDF$Mod <- "True"
DataDF$CI_low <- DataDF$CI_up  <-  DataDF$Pred <- DataDF$Pred_low <- DataDF$Pred_up <- DataDF$Fit
DataDF <- DataDF %>% filter(Year > 20)
ggplot(data = DataDF, aes(x=S, y=Fit)) +
geom_line(size = 1.5, col = "red") +
geom_point(aes(x=S, y=R), col = "black")
ggplot(data = DataDF, aes(x=Year, y=R)) +
geom_line(size = 1.5) +
geom_line(aes(x=Year, y=Fit), col = "red")
# run using TMB, without prior
TMB_No_Prior <- RunLarkin(Data = DataDF,
Fitting_SW = "TMB",
Priors = F, Name = "TMB_No_Prior")
# In forecast version all priors for betas are 0, 0.001
# Now run with priors same as "true" values
TMB_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "TMB",
Priors = T, Name = "TMB_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
# Run same model as mcmc using tmbstan
library(tmbstan)
tmbstan_True_Prior <- RunLarkin(Data = DataDF,  Fitting_SW = "tmbstan",
Priors = T,  Name = "tmbstan_True_Prior",
logA_mean = log(SimData$true_a), logA_sig = 0.5, # priors on logAlpha
Sig_Gam_Dist = 0.001, # inverse gamma shape and scale param
B_means = SimData$true_b, B_sigs = SimData$true_b/4)
All_Ests <- bind_rows(DataDF, TMB_No_Prior$Fit, TMB_True_Prior$Fit, tmbstan_True_Prior$Fit) #,
# Now plot all to compare
ggplot(data = All_Ests, aes(x=S, y=Fit, ymin = CI_low, ymax = CI_up, col = Mod, fill= Mod)) +
geom_line(size = 1.5) +
geom_ribbon( alpha = 0.1) +
geom_point(aes(x=S, y=R), col = "black") +
geom_ribbon(aes(x=S, y=Pred, ymin = Pred_low, ymax = Pred_up, fill= Mod),
alpha = 0.05) +
theme_bw()
# Now plot all to compare
ggplot(data = All_Ests, aes(x=S, y=Fit, ymin = CI_low, ymax = CI_up, col = Mod, fill= Mod)) +
geom_line(size = 1.5) +
geom_ribbon( alpha = 0.1) +
geom_point(aes(x=S, y=R), col = "black") +
geom_ribbon(aes(x=S, y=Pred, ymin = Pred_low, ymax = Pred_up, fill= Mod),
alpha = 0.05) +
theme_bw()
